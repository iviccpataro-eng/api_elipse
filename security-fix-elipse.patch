diff --git a/middleware/auth.js b/middleware/auth.js
index 0000000..1111111 100644
--- a/middleware/auth.js
+++ b/middleware/auth.js
@@ -1,35 +1,101 @@
-import jwt from "jsonwebtoken";
-import dotenv from "dotenv";
-
-dotenv.config();
-
-const SECRET = process.env.JWT_SECRET || "9a476d73d3f307125384a4728279ad9c";
-const FIXED_ENV_TOKEN = import.meta.env?.VITE_REACT_TOKEN || null;
-
-export function autenticar(req, res, next) {
-  const authHeader = req.headers["authorization"];
-  if (!authHeader) return res.status(401).json({ erro: "Token não enviado" });
-
-  const token = authHeader.split(" ")[1];
-
-  if (token === FIXED_ENV_TOKEN) {
-    req.user = { id: "system", role: "system" };
-    return next();
-  }
-
-  try {
-    const decoded = jwt.verify(token, SECRET);
-    req.user = decoded;
-    next();
-  } catch (err) {
-    return res.status(403).json({ erro: "Token inválido" });
-  }
-}
-
-export function somenteAdmin(req, res, next) {
-  if (req.user?.role !== "admin")
-    return res.status(403).json({ erro: "Acesso restrito a administradores." });
-  next();
-}
+import jwt from "jsonwebtoken";
+import dotenv from "dotenv";
+
+dotenv.config();
+
+const SECRET = process.env.JWT_SECRET || "9a476d73d3f307125384a4728279ad9c";
+const FIXED_ENV_TOKEN = process.env.ELIPSE_FIXED_TOKEN || null;
+
+/**
+ * Middleware de autenticação:
+ * - Aceita token fixo (apenas para POST em /dados/* ou /data/*)
+ * - Ou valida JWT de usuários normais
+ */
+export function autenticar(req, res, next) {
+  const authHeader = req.headers["authorization"];
+  if (!authHeader) {
+    console.warn("[AUTH] Nenhum Authorization header recebido");
+    return res.status(401).json({ erro: "Token não enviado" });
+  }
+
+  const parts = authHeader.split(" ");
+  const token = parts.length >= 2 ? parts[1] : parts[0];
+  if (!token || token === "undefined") {
+    console.warn("[AUTH] Token ausente ou indefinido");
+    return res.status(401).json({ erro: "Token ausente ou inválido" });
+  }
+
+  try {
+    // --- Caso: token fixo do Elipse ---
+    if (FIXED_ENV_TOKEN && token === FIXED_ENV_TOKEN) {
+      const method = (req.method || "").toUpperCase();
+      const url = (req.originalUrl || req.url || "").toLowerCase();
+
+      // Permitir SOMENTE: POST em /dados/* ou /data/*
+      const allowed =
+        method === "POST" &&
+        (url === "/dados" ||
+          url === "/data" ||
+          url.startsWith("/dados/") ||
+          url.startsWith("/data/"));
+
+      if (!allowed) {
+        console.warn(
+          `[AUTH] Token fixo usado em rota/método não permitido: ${method} ${url}`
+        );
+        return res
+          .status(403)
+          .json({ erro: "Fixed token somente permitido para POST em /dados ou /data" });
+      }
+
+      // Autenticação bem-sucedida para integração Elipse
+      req.user = {
+        id: "elipse-post",
+        user: "elipse",
+        role: "system",
+        authSource: "fixed-token",
+      };
+      return next();
+    }
+
+    // --- Caso: JWT normal ---
+    const payload = jwt.verify(token, SECRET);
+    req.user = payload;
+    return next();
+  } catch (err) {
+    console.warn("[AUTH] Token inválido:", err && err.message ? err.message : err);
+    return res.status(403).json({ erro: "Token inválido ou malformado" });
+  }
+}
+
+/**
+ * Middleware de permissão: restringe a administradores
+ */
+export function somenteAdmin(req, res, next) {
+  if (req.user?.role !== "admin") {
+    return res.status(403).json({ erro: "Acesso restrito a administradores." });
+  }
+  next();
+}
diff --git a/routes/data.js b/routes/data.js
index 0000000..2222222 100644
--- a/routes/data.js
+++ b/routes/data.js
@@ -1,25 +1,93 @@
-import express from "express";
-import { autenticar } from "../middleware/auth.js";
-import { setByPath, getByPath } from "../utils/helpers.js";
-
-const router = express.Router();
-let dados = {};
-
-router.get(["/dados", "/data"], autenticar, (req, res) => {
-  res.json(dados);
-});
-
-router.get(["/dados/*", "/data/*"], autenticar, (req, res) => {
-  const path = req.params[0];
-  const ref = getByPath(dados, path);
-  res.json(ref || {});
-});
-
-router.post(["/dados/*", "/data/*"], autenticar, (req, res) => {
-  const path = req.params[0];
-  setByPath(dados, path, req.body);
-  res.json({ status: "OK" });
-});
-
-export default router;
+import express from "express";
+import { autenticar } from "../middleware/auth.js";
+import { setByPath, getByPath, normalizeBody } from "../utils/helpers.js";
+import crypto from "crypto";
+
+const router = express.Router();
+
+// Dados em memória (sem persistência)
+let dados = {};
+
+/* ----------------------------
+   Helpers internos
+---------------------------- */
+function sha256Hex(obj) {
+  const txt = typeof obj === "string" ? obj : JSON.stringify(obj || "");
+  return crypto.createHash("sha256").update(txt).digest("hex");
+}
+
+/* ----------------------------
+   Rotas
+---------------------------- */
+
+// GET raiz: retorna todo o objeto (requer autenticação)
+router.get(["/dados", "/data"], autenticar, (req, res) => {
+  return res.json(dados);
+});
+
+// GET /dados/* ou /data/* : retorna nó específico
+router.get(["/dados/*", "/data/*"], autenticar, (req, res) => {
+  const path = req.params[0] || "";
+  const ref = getByPath(dados, path);
+  if (typeof ref === "undefined")
+    return res.status(404).json({ erro: "Caminho não encontrado" });
+  return res.json(ref);
+});
+
+/**
+ * POST /dados/* ou /data/* :
+ * - aceita payloads JSON normais e também payloads com { valor: "<base64>" }
+ *   (normalizeBody faz a conversão, conforme helpers.js do projeto).
+ * - só permite gravação para roles diferentes de 'reader'.
+ * - aceita também o token fixo do Elipse (conforme middleware) — porém o middleware
+ *   já restringe o uso do fixed token apenas a POST /dados* e /data*.
+ */
+router.post(["/dados/*", "/data/*"], autenticar, (req, res) => {
+  const path = req.params[0] || "";
+
+  try {
+    // Decodifica payload quando for Base64 (helper já no projeto)
+    const payload = normalizeBody(req);
+
+    if (!payload || typeof payload !== "object") {
+      return res.status(400).json({ erro: "Payload inválido ou formato não suportado" });
+    }
+
+    // Autorização adicional: leitores não podem gravar
+    const role = req.user?.role || "anonymous";
+    if (role === "reader") {
+      return res.status(403).json({ erro: "Role sem permissão para gravar" });
+    }
+
+    // Auditoria mínima: log com quem gravou, caminho, timestamp e hash do payload
+    const who = req.user?.user || req.user?.id || "unknown";
+    const ts = new Date().toISOString();
+    const h = sha256Hex(payload);
+    console.info(`[DATA][WRITE] user=${who} role=${role} path="/${path}" ts=${ts} hash=${h}`);
+
+    // Grava em memória (igual ao comportamento original)
+    setByPath(dados, path, payload);
+
+    return res.json({
+      status: "OK",
+      salvo: payload,
+      meta: { path: `/${path}`, hash: h, savedAt: ts },
+    });
+  } catch (e) {
+    console.error("[DATA] Erro ao processar POST /dados:", e && e.message ? e.message : e);
+    return res.status(400).json({ erro: e.message || "Erro ao processar payload" });
+  }
+});
+
+export default router;
